\section{Appendix}
\appendix

\label{app-def-generic-datatypes}
\section{Definition Generic Datatypes}
\begin{haskell}
data I r         = I r                  
data K a r       = K a                  
data (:+:) f g r = Inl (f r) | Inr (g r)
data (:*:) f g r = Pair (f r, g r)      
\end{haskell}

\label{app-def-fixpoint}
\section{Definition Fixpoint}
\begin{haskell}
data Fix f = In { unFix :: f (Fix f) }

instance Eq (f (Fix f)) => Eq (Fix f) where
    f == g = unFix f == unFix g

instance Show (f (Fix f)) => Show (Fix f) where
    show = show . unFix
\end{haskell}

\label{app-impl-merkelize}
\section{Implementation Merkelize}
\begin{haskell}
instance (Show a) => Merkelize (K a) where
  merkleIn (K x) = Pair (K x, K h)
    where
      h = digestConcat [digest "K", digest x]

instance Merkelize I where
  merkleIn (I x) = Pair (I prevX, K h)
    where
      prevX@(In (Pair (_, K ph))) = merkle x
      h = digestConcat [digest "I", ph]

instance (Merkelize f, Merkelize g) => Merkelize (f :+: g) where
  merkleIn (Inl x) = Pair (Inl prevX, K h)
    where
      (Pair (prevX, K ph)) = merkleIn x
      h = digestConcat [digest "Inl", ph]
  merkleIn (Inr x) = Pair (Inr prevX, K h)
    where
      (Pair (prevX, K ph)) = merkleIn x
      h = digestConcat [digest "Inr", ph]

instance (Merkelize f, Merkelize g) => Merkelize (f :*: g) where
  merkleIn (Pair (x, y)) = Pair (Pair (prevX, prevY), K h)
    where
      (Pair (prevX, K phx)) = merkleIn x
      (Pair (prevY, K phy)) = merkleIn y
      h = digestConcat [digest "Pair", phx, phy]
\end{haskell}

\label{app-impl-cata-sum-inter-results}
\section{Implementation Cata Sum with Intermediate Results}
\begin{haskell}
cataMerkleTree :: TreeG Int -> (M.Map String Int, Int)
cataMerkleTree t = cata sumTree merkleTree
  where
    merkleTree :: Fix (TreeF a :*: K Digest)
    merkleTree = merkle t

    sumTree :: (TreeG Int :*: K Digest) Int -> Int
    sumTree (Pair (px, K h)) = case px of
      -- Leaf  
      Inl (K x)                       
        -> (M.insert h x M.empty, x) 
      -- Node
      Inr (Pair (Pair (I (xl, ml), K x), I (xr, mr))) 
        -> let n = x + xl + xr 
           in (M.insert h n (ml <> mr), n) 
\end{haskell}